Description: Upgrades androiddeployqt and Qt5AndroidSupport.cmake from Krita's
5.15.7 to 5.15.17, which fixes a bunch of issues with it that prevent Drawpile
from building.

--- a/src/corelib/Qt5AndroidSupport.cmake
+++ b/src/corelib/Qt5AndroidSupport.cmake
@@ -1,3 +1,18 @@
+function(qt_internal_get_highest_android_sdk_build_tools_revision out_var build_tools_dir)
+  file(GLOB revisions RELATIVE "${build_tools_dir}" "${build_tools_dir}/*")
+  if(NOT revisions)
+    message(FATAL_ERROR "Cannot determine version of Android build tools. "
+      "Please specify ANDROID_SDK_BUILD_TOOLS_REVISION manually.")
+  endif()
+  set(highest_revision 1.0)
+  foreach(revision IN LISTS revisions)
+    if(revision VERSION_GREATER highest_revision)
+      set(highest_revision ${revision})
+    endif()
+  endforeach()
+  set(${out_var} ${highest_revision} PARENT_SCOPE)
+endfunction()
+
 if (NOT ${PROJECT_NAME}-MultiAbiBuild)

   set(ANDROID_ABIS armeabi-v7a arm64-v8a x86 x86_64)
@@ -18,8 +33,8 @@ if (NOT ${PROJECT_NAME}-MultiAbiBuild)
       option(ANDROID_BUILD_ABI_${abi} "Enable the build for Android ${abi}" ${abi_initial_value})
     endif()
   endforeach()
-  option(ANDROID_MIN_SDK_VERSION "Android minimum SDK version" "21")
-  option(ANDROID_TARGET_SDK_VERSION "Android target SDK version" "30")
+  set(ANDROID_MIN_SDK_VERSION "21" CACHE STRING "Android minimum SDK version")
+  set(ANDROID_TARGET_SDK_VERSION "30" CACHE STRING "Android target SDK version")

   # Make sure to delete the "android-build" directory, which contains all the
   # build artefacts, and also the androiddeployqt/gradle artefacts
@@ -50,6 +65,8 @@ if (NOT ${PROJECT_NAME}-MultiAbiBuild)
   @QT_ANDROID_PACKAGE_SOURCE_DIR@
   @QT_ANDROID_VERSION_CODE@
   @QT_ANDROID_VERSION_NAME@
+  @QT_ANDROID_TARGET_SDK_VERSION@
+  @QT_ANDROID_MIN_SDK_VERSION@
   @QT_ANDROID_EXTRA_LIBS@
   @QT_QML_IMPORT_PATH@
   "ndk": "@ANDROID_NDK@",
@@ -57,6 +74,7 @@ if (NOT ${PROJECT_NAME}-MultiAbiBuild)
   "qml-root-path": "@CMAKE_CURRENT_SOURCE_DIR@",
   "qt": "@QT_DIR@",
   "sdk": "@ANDROID_SDK@",
+  "sdkBuildToolsRevision": "@ANDROID_SDK_BUILD_TOOLS_REVISION@",
   "stdcpp-path": "@ANDROID_TOOLCHAIN_ROOT@/sysroot/usr/lib/",
   "tool-prefix": "llvm",
   "toolchain-prefix": "llvm",
@@ -71,6 +89,12 @@ if (NOT ${PROJECT_NAME}-MultiAbiBuild)
     get_filename_component(ANDROID_SDK ${ANDROID_NDK}/../ ABSOLUTE)
   endif()

+  if("${ANDROID_SDK_BUILD_TOOLS_REVISION}" STREQUAL "")
+    qt_internal_get_highest_android_sdk_build_tools_revision(
+      ANDROID_SDK_BUILD_TOOLS_REVISION
+      "${ANDROID_SDK}/build-tools")
+  endif()
+
   find_program(ANDROID_DEPLOY_QT androiddeployqt)
   get_filename_component(QT_DIR ${ANDROID_DEPLOY_QT}/../../ ABSOLUTE)

@@ -103,8 +127,8 @@ if (NOT ${PROJECT_NAME}-MultiAbiBuild)
   generate_json_variable(ANDROID_VERSION_NAME "android-version-name")
   generate_json_variable_list(ANDROID_EXTRA_LIBS "android-extra-libs")
   generate_json_variable_list(QML_IMPORT_PATH "qml-import-paths")
-  generate_json_variable_list(ANDROID_MIN_SDK_VERSION "android-min-sdk-version")
-  generate_json_variable_list(ANDROID_TARGET_SDK_VERSION "android-target-sdk-version")
+  generate_json_variable(ANDROID_MIN_SDK_VERSION "android-min-sdk-version")
+  generate_json_variable(ANDROID_TARGET_SDK_VERSION "android-target-sdk-version")


   configure_file(
--- a/src/tools/androiddeployqt/main.cpp
+++ b/src/tools/androiddeployqt/main.cpp
@@ -129,7 +129,6 @@ struct Options
         , internalSf(false)
         , sectionsOnly(false)
         , protectedAuthenticationPath(false)
-        , jarSigner(false)
         , installApk(false)
         , uninstallApk(false)
     {}
@@ -157,6 +156,7 @@ struct Options
     QString sdkPath;
     QString sdkBuildToolsVersion;
     QString ndkPath;
+    QString ndkVersion;
     QString jdkPath;

     // Build paths
@@ -174,7 +174,7 @@ struct Options
     QString versionName;
     QString versionCode;
     QByteArray minSdkVersion{"21"};
-    QByteArray targetSdkVersion{"30"};
+    QByteArray targetSdkVersion{"31"};

     // lib c++ path
     QString stdCppPath;
@@ -213,7 +213,6 @@ struct Options
     bool internalSf;
     bool sectionsOnly;
     bool protectedAuthenticationPath;
-    bool jarSigner;
     QString apkPath;

     // Installation information
@@ -343,7 +342,7 @@ QString fileArchitecture(const Options &options, const QString &path)
         return {};
     }

-    readElf = QLatin1String("%1 -needed-libs %2").arg(shellQuote(readElf), shellQuote(path));
+    readElf = QLatin1String("%1 --needed-libs %2").arg(shellQuote(readElf), shellQuote(path));

     FILE *readElfCommand = openProcess(readElf);
     if (!readElfCommand) {
@@ -422,7 +421,6 @@ Options parseOptions()
         } else if (argument.compare(QLatin1String("--aab"), Qt::CaseInsensitive) == 0) {
             options.buildAAB = true;
             options.build = true;
-            options.jarSigner = true;
         } else if (!options.buildAAB && argument.compare(QLatin1String("--no-build"), Qt::CaseInsensitive) == 0) {
             options.build = false;
         } else if (argument.compare(QLatin1String("--install"), Qt::CaseInsensitive) == 0) {
@@ -525,8 +523,6 @@ Options parseOptions()
             options.sectionsOnly = true;
         } else if (argument.compare(QLatin1String("--protected"), Qt::CaseInsensitive) == 0) {
             options.protectedAuthenticationPath = true;
-        } else if (argument.compare(QLatin1String("--jarsigner"), Qt::CaseInsensitive) == 0) {
-            options.jarSigner = true;
         } else if (argument.compare(QLatin1String("--aux-mode"), Qt::CaseInsensitive) == 0) {
             options.auxMode = true;
         }
@@ -597,8 +593,7 @@ void printHelp()
                     "         --internalsf: Include the .SF file inside the signature block.\n"
                     "         --sectionsonly: Don't compute hash of entire manifest.\n"
                     "         --protected: Keystore has protected authentication path.\n"
-                    "         --jarsigner: Force jarsigner usage, otherwise apksigner will be\n"
-                    "           used if available.\n"
+                    "         --jarsigner: Deprecated, ignored.\n"
                     "    --jdk <path/to/jdk>: Used to find the jarsigner tool when used\n"
                     "       in combination with the --release argument. By default,\n"
                     "       an attempt is made to detect the tool using the JAVA_HOME and\n"
@@ -893,6 +888,30 @@ bool readInputFile(Options *options)
         options->ndkPath = ndk.toString();
     }

+    {
+        const QString ndkPropertiesPath = options->ndkPath + QStringLiteral("/source.properties");
+        QFile file(ndkPropertiesPath);
+        if (file.open(QIODevice::ReadOnly | QIODevice::Text)) {
+            const char pkgRevisionKey[] = "Pkg.Revision";
+            while (!file.atEnd()) {
+                const QByteArray line = file.readLine();
+                if (line.startsWith(pkgRevisionKey)) {
+                    const QList<QByteArray> parts = line.split('=');
+                    if (parts.size() == 2 && parts.at(0).trimmed() == QByteArray(pkgRevisionKey)) {
+                        options->ndkVersion = QString::fromLocal8Bit(parts.at(1).trimmed());
+                        break;
+                    }
+                }
+            }
+        }
+
+        if (options->ndkVersion.isEmpty()) {
+            fprintf(stderr, "Couldn't retrieve the NDK version from \"%s\".\n",
+                    qPrintable(ndkPropertiesPath));
+            return false;
+        }
+    }
+
     {
         const QJsonValue toolchainPrefix = jsonObject.value(QLatin1String("toolchain-prefix"));
         if (toolchainPrefix.isUndefined()) {
@@ -986,12 +1005,19 @@ bool readInputFile(Options *options)
                         }
                     }
                 } else {
-                    auto arch = fileArchitecture(*options, path);
-                    if (!arch.isEmpty()) {
-                        options->qtDependencies[arch].append(QtDependency(dependency.toString(), path));
-                    } else if (options->verbose) {
-                        fprintf(stderr, "Skipping \"%s\", unknown architecture\n", qPrintable(path));
-                        fflush(stderr);
+                    if (dependency.endsWith(QLatin1String(".so"))) {
+                        auto arch = fileArchitecture(*options, path);
+                        if (!arch.isEmpty()) {
+                            options->qtDependencies[arch].append(QtDependency(dependency.toString(), path));
+                        } else if (options->verbose) {
+                            fprintf(stderr, "Skipping \"%s\", unknown architecture\n", qPrintable(path));
+                            fflush(stderr);
+                        }
+                    } else {
+                        if (dependency.endsWith(QLatin1String(".jar")))
+                            options->localJars.append(dependency.toString());
+                        for (auto arch : options->architectures.keys())
+                            options->qtDependencies[arch].append(QtDependency(dependency.toString(), path));
                     }
                 }
             }
@@ -1292,25 +1318,19 @@ bool updateLibsXml(Options *options)
         if (localLibs.isEmpty()) {
             QString plugin;
             for (const QtDependency &qtDependency : options->qtDependencies[it.key()]) {
-                if (qtDependency.relativePath.endsWith(QLatin1String("libqtforandroid.so"))
-                        || qtDependency.relativePath.endsWith(QLatin1String("libqtforandroidGL.so"))) {
-                    if (!plugin.isEmpty() && plugin != qtDependency.relativePath) {
-                        fprintf(stderr, "Both platform plugins libqtforandroid.so and libqtforandroidGL.so included in package. Please include only one.\n");
-                        return false;
-                    }
-
+                if (qtDependency.relativePath.contains(QLatin1String("libplugins_platforms_qtforandroid_")))
                     plugin = qtDependency.relativePath;
-                }
+
                 if (qtDependency.relativePath.contains(QLatin1String("libQt5OpenGL"))
                         || qtDependency.relativePath.contains(QLatin1String("libQt5Quick"))) {
                     options->usesOpenGL |= true;
-                    break;
                 }
             }

             if (plugin.isEmpty()) {
                 fflush(stdout);
-                fprintf(stderr, "No platform plugin, neither libqtforandroid.so or libqtforandroidGL.so, included in package. Please include one.\n");
+                fprintf(stderr, "No platform plugin (libplugins_platforms_qtforandroid.so) included"
+                                " in the deployment. Make sure the app links to Qt Gui library.\n");
                 fflush(stderr);
                 return false;
             }
@@ -1513,11 +1533,6 @@ QList<QtDependency> findFilesRecursively(const Options &options, const QString &
     return findFilesRecursively(options, info, options.qtInstallDirectory + QLatin1Char('/'));
 }

-bool readDependenciesFromElf(Options *options,
-                             const QString &fileName,
-                             QSet<QString> *usedDependencies,
-                             QSet<QString> *remainingDependencies);
-
 bool readAndroidDependencyXml(Options *options,
                               const QString &moduleName,
                               QSet<QString> *usedDependencies,
@@ -1563,12 +1578,6 @@ bool readAndroidDependencyXml(Options *options,
                             fprintf(stdout, "Appending dependency from xml: %s\n", qPrintable(fileName.relativePath));

                         options->qtDependencies[options->currentArchitecture].append(fileName);
-
-                        // recursively load dependencies of the plugins we added
-                        if (!readDependenciesFromElf(options, fileName.absolutePath, usedDependencies, remainingDependencies)) {
-                            fprintf(stderr, "Error fetching deps from %s\n", qPrintable(fileName.absolutePath));
-                            return false;
-                        }
                     }
                 } else if (reader.name() == QLatin1String("jar")) {
                     int bundling = reader.attributes().value(QLatin1String("bundling")).toInt();
@@ -1640,7 +1649,7 @@ QStringList getQtLibsFromElf(const Options &options, const QString &fileName)
         return QStringList();
     }

-    readElf = QLatin1String("%1 -needed-libs %2").arg(shellQuote(readElf), shellQuote(fileName));
+    readElf = QLatin1String("%1 --needed-libs %2").arg(shellQuote(readElf), shellQuote(fileName));

     FILE *readElfCommand = openProcess(readElf);
     if (!readElfCommand) {
@@ -2281,15 +2290,16 @@ static GradleProperties readGradleProperties(const QString &path)

 static bool mergeGradleProperties(const QString &path, GradleProperties properties)
 {
-    QFile::remove(path + QLatin1Char('~'));
-    QFile::rename(path, path + QLatin1Char('~'));
+    const QString oldPathStr = path + QLatin1Char('~');
+    QFile::remove(oldPathStr);
+    QFile::rename(path, oldPathStr);
     QFile file(path);
     if (!file.open(QIODevice::Truncate | QIODevice::WriteOnly | QIODevice::Text)) {
         fprintf(stderr, "Can't open file: %s for writing\n", qPrintable(file.fileName()));
         return false;
     }

-    QFile oldFile(path + QLatin1Char('~'));
+    QFile oldFile(oldPathStr);
     if (oldFile.open(QIODevice::ReadOnly)) {
         while (!oldFile.atEnd()) {
             QByteArray line(oldFile.readLine());
@@ -2305,6 +2315,7 @@ static bool mergeGradleProperties(const QString &path, GradleProperties properti
             file.write(line);
         }
         oldFile.close();
+        QFile::remove(oldPathStr);
     }

     for (GradleProperties::const_iterator it = properties.begin(); it != properties.end(); ++it)
@@ -2321,8 +2332,9 @@ void checkAndWarnGradleLongPaths(const QString &outputDirectory)
     QDirIterator it(outputDirectory, QStringList(QStringLiteral("*.java")), QDir::Files,
                     QDirIterator::Subdirectories);
     while (it.hasNext()) {
-        if (it.next().size() >= MAX_PATH)
-            longFileNames.append(it.next());
+        const QString &filePath = it.next();
+        if (filePath.size() >= MAX_PATH)
+            longFileNames.append(filePath);
     }

     if (!longFileNames.isEmpty()) {
@@ -2335,26 +2347,88 @@ void checkAndWarnGradleLongPaths(const QString &outputDirectory)
 }
 #endif

+struct GradleFlags {
+    bool setsLegacyPackaging = false;
+    bool usesIntegerCompileSdkVersion = false;
+};
+
+GradleFlags gradleBuildFlags(const QString &path)
+{
+    GradleFlags flags;
+
+    QFile file(path);
+    if (!file.open(QIODevice::ReadOnly))
+        return flags;
+
+    auto isComment = [](const QByteArray &line) {
+        const auto trimmed = line.trimmed();
+        return trimmed.startsWith("//") || trimmed.startsWith('*') || trimmed.startsWith("/*");
+    };
+
+    const auto lines = file.readAll().split('\n');
+    for (const auto &line : lines) {
+        if (isComment(line))
+            continue;
+        if (line.contains("useLegacyPackaging")) {
+            flags.setsLegacyPackaging = true;
+        } else if (line.contains("compileSdkVersion androidCompileSdkVersion.toInteger()")) {
+            flags.usesIntegerCompileSdkVersion = true;
+        }
+    }
+
+    return flags;
+}
+
 bool buildAndroidProject(const Options &options)
 {
     GradleProperties localProperties;
     localProperties["sdk.dir"] = QDir::fromNativeSeparators(options.sdkPath).toUtf8();
-    // localProperties["local_ndk.dir"] = QDir::fromNativeSeparators(options.ndkPath).toUtf8();
-
-    if (!mergeGradleProperties(options.outputDirectory + QLatin1String("local.properties"), localProperties))
+    const QString localPropertiesPath = options.outputDirectory + QLatin1String("local.properties");
+    if (!mergeGradleProperties(localPropertiesPath, localProperties))
         return false;

-    QString gradlePropertiesPath = options.outputDirectory + QLatin1String("gradle.properties");
+    const QString gradlePropertiesPath = options.outputDirectory + QLatin1String("gradle.properties");
     GradleProperties gradleProperties = readGradleProperties(gradlePropertiesPath);
-    gradleProperties["android.packagingOptions.jniLibs.useLegacyPackaging"] = "true";
+
+    const QString gradleBuildFilePath = options.outputDirectory + QLatin1String("build.gradle");
+    GradleFlags gradleFlags = gradleBuildFlags(gradleBuildFilePath);
+    if (!gradleFlags.setsLegacyPackaging)
+        gradleProperties["android.bundle.enableUncompressedNativeLibs"] = "false";
+
     gradleProperties["buildDir"] = "build";
     gradleProperties["qt5AndroidDir"] = (options.qtInstallDirectory + QLatin1String("/src/android/java")).toUtf8();
-    gradleProperties["androidCompileSdkVersion"] = options.androidPlatform.split(QLatin1Char('-')).last().toLocal8Bit();
+
+    QByteArray sdkPlatformVersion;
+    // Provide the integer version only if build.gradle explicitly converts to Integer,
+    // to avoid regression to existing projects that build for sdk platform of form android-xx.
+    if (gradleFlags.usesIntegerCompileSdkVersion) {
+        const QByteArray tmp = options.androidPlatform.split(QLatin1Char('-')).last().toLocal8Bit();
+        bool ok;
+        tmp.toInt(&ok);
+        if (ok) {
+            sdkPlatformVersion = tmp;
+        } else {
+            fprintf(stderr, "Warning: Gradle expects SDK platform version to be an integer, "
+                            "but the set version is not convertible to an integer.");
+        }
+    }
+
+    if (sdkPlatformVersion.isEmpty())
+        sdkPlatformVersion = options.androidPlatform.toLocal8Bit();
+
+    gradleProperties["androidCompileSdkVersion"] = sdkPlatformVersion;
     gradleProperties["qtMinSdkVersion"] = options.minSdkVersion;
     gradleProperties["qtTargetSdkVersion"] = options.targetSdkVersion;
+    gradleProperties["androidNdkVersion"] = options.ndkVersion.toUtf8();
     if (gradleProperties["androidBuildToolsVersion"].isEmpty())
         gradleProperties["androidBuildToolsVersion"] = options.sdkBuildToolsVersion.toLocal8Bit();
-
+    QString abiList;
+    for (auto it = options.architectures.constBegin(); it != options.architectures.constEnd(); ++it) {
+        if (abiList.size())
+            abiList.append(u",");
+        abiList.append(it.key());
+    }
+    gradleProperties["qtTargetAbiList"] = abiList.toLocal8Bit();// armeabi-v7a or arm64-v8a or ...
     if (!mergeGradleProperties(gradlePropertiesPath, gradleProperties))
         return false;

@@ -2476,7 +2550,7 @@ QString packagePath(const Options &options, PackageType pt)
             path += QLatin1String(".aab");
         }
     }
-    return shellQuote(path);
+    return path;
 }

 bool installApk(const Options &options)
@@ -2541,7 +2615,7 @@ bool copyStdCpp(Options *options)
     return copyFileIfNewer(stdCppPath, destinationFile, *options);
 }

-bool jarSignerSignPackage(const Options &options)
+bool signAAB(const Options &options)
 {
     if (options.verbose)
         fprintf(stdout, "Signing Android package.\n");
@@ -2600,12 +2674,13 @@ bool jarSignerSignPackage(const Options &options)
     if (options.protectedAuthenticationPath)
         jarSignerTool += QLatin1String(" -protected");

-    auto signPackage = [&](const QString &file) {
+    auto jarSignPackage = [&](const QString &file) {
         fprintf(stdout, "Signing file %s\n", qPrintable(file));
         fflush(stdout);
-        QString command = jarSignerTool + QLatin1String(" %1 %2")
-                .arg(file)
-                .arg(shellQuote(options.keyStoreAlias));
+        QString command = jarSignerTool
+                + QLatin1String(" %1 %2")
+                          .arg(shellQuote(file))
+                          .arg(shellQuote(options.keyStoreAlias));

         FILE *jarSignerCommand = openProcess(command);
         if (jarSignerCommand == 0) {
@@ -2629,52 +2704,9 @@ bool jarSignerSignPackage(const Options &options)
         return true;
     };

-    if (!signPackage(packagePath(options, UnsignedAPK)))
-        return false;
-    if (options.buildAAB && !signPackage(packagePath(options, AAB)))
-        return false;
-
-    QString zipAlignTool = options.sdkPath + QLatin1String("/tools/zipalign");
-#if defined(Q_OS_WIN32)
-    zipAlignTool += QLatin1String(".exe");
-#endif
-
-    if (!QFile::exists(zipAlignTool)) {
-        zipAlignTool = options.sdkPath + QLatin1String("/build-tools/") + options.sdkBuildToolsVersion + QLatin1String("/zipalign");
-#if defined(Q_OS_WIN32)
-        zipAlignTool += QLatin1String(".exe");
-#endif
-        if (!QFile::exists(zipAlignTool)) {
-            fprintf(stderr, "zipalign tool not found: %s\n", qPrintable(zipAlignTool));
-            return false;
-        }
-    }
-
-    zipAlignTool = QLatin1String("%1%2 -f 4 %3 %4")
-            .arg(shellQuote(zipAlignTool),
-                 options.verbose ? QLatin1String(" -v") : QLatin1String(),
-                 packagePath(options, UnsignedAPK),
-                 packagePath(options, SignedAPK));
-
-    FILE *zipAlignCommand = openProcess(zipAlignTool);
-    if (zipAlignCommand == 0) {
-        fprintf(stderr, "Couldn't run zipalign.\n");
-        return false;
-    }
-
-    char buffer[512];
-    while (fgets(buffer, sizeof(buffer), zipAlignCommand) != 0)
-        fprintf(stdout, "%s", buffer);
-
-    int errorCode = pclose(zipAlignCommand);
-    if (errorCode != 0) {
-        fprintf(stderr, "zipalign command failed.\n");
-        if (!options.verbose)
-            fprintf(stderr, "  -- Run with --verbose for more information.\n");
+    if (options.buildAAB && !jarSignPackage(packagePath(options, AAB)))
         return false;
-    }
-
-    return QFile::remove(packagePath(options, UnsignedAPK));
+    return true;
 }

 bool signPackage(const Options &options)
@@ -2683,12 +2715,6 @@ bool signPackage(const Options &options)
 #if defined(Q_OS_WIN32)
     apksignerTool += QLatin1String(".bat");
 #endif
-
-    if (options.jarSigner || !QFile::exists(apksignerTool))
-        return jarSignerSignPackage(options);
-
-    // APKs signed with apksigner must not be changed after they're signed, therefore we need to zipalign it before we sign it.
-
     QString zipAlignTool = options.sdkPath + QLatin1String("/tools/zipalign");
 #if defined(Q_OS_WIN32)
     zipAlignTool += QLatin1String(".exe");
@@ -2719,10 +2745,11 @@ bool signPackage(const Options &options)
         return pclose(zipAlignCommand) == 0;
     };

-    const QString verifyZipAlignCommandLine = QLatin1String("%1%2 -c 4 %3")
-            .arg(shellQuote(zipAlignTool),
-                 options.verbose ? QLatin1String(" -v") : QLatin1String(),
-                 packagePath(options, UnsignedAPK));
+    const QString verifyZipAlignCommandLine =
+            QLatin1String("%1%2 -c 4 %3")
+                    .arg(shellQuote(zipAlignTool),
+                         options.verbose ? QLatin1String(" -v") : QLatin1String(),
+                         shellQuote(packagePath(options, UnsignedAPK)));

     if (zipalignRunner(verifyZipAlignCommandLine)) {
         if (options.verbose)
@@ -2739,11 +2766,12 @@ bool signPackage(const Options &options)
         if (options.verbose)
             fprintf(stdout, "APK not aligned, aligning it for signing.\n");

-        const QString zipAlignCommandLine = QLatin1String("%1%2 -f 4 %3 %4")
-                .arg(shellQuote(zipAlignTool),
-                     options.verbose ? QLatin1String(" -v") : QLatin1String(),
-                     packagePath(options, UnsignedAPK),
-                     packagePath(options, SignedAPK));
+        const QString zipAlignCommandLine =
+                QLatin1String("%1%2 -f 4 %3 %4")
+                        .arg(shellQuote(zipAlignTool),
+                             options.verbose ? QLatin1String(" -v") : QLatin1String(),
+                             shellQuote(packagePath(options, UnsignedAPK)),
+                             shellQuote(packagePath(options, SignedAPK)));

         if (!zipalignRunner(zipAlignCommandLine)) {
             fprintf(stderr, "zipalign command failed.\n");
@@ -2768,8 +2796,7 @@ bool signPackage(const Options &options)
     if (options.verbose)
         apkSignerCommandLine += QLatin1String(" --verbose");

-    apkSignerCommandLine += QLatin1String(" %1")
-            .arg(packagePath(options, SignedAPK));
+    apkSignerCommandLine += QLatin1String(" %1").arg(shellQuote(packagePath(options, SignedAPK)));

     auto apkSignerRunner = [&] {
         FILE *apkSignerCommand = openProcess(apkSignerCommandLine);
@@ -2796,8 +2823,12 @@ bool signPackage(const Options &options)
     if (!apkSignerRunner())
         return false;

-    apkSignerCommandLine = QLatin1String("%1 verify --verbose %2")
-        .arg(shellQuote(apksignerTool), packagePath(options, SignedAPK));
+    apkSignerCommandLine =
+            QLatin1String("%1 verify --verbose %2")
+                    .arg(shellQuote(apksignerTool), shellQuote(packagePath(options, SignedAPK)));
+
+    if (options.buildAAB && !signAAB(options))
+      return false;

     // Verify the package and remove the unsigned apk
     return apkSignerRunner() && QFile::remove(packagePath(options, UnsignedAPK));
@@ -2954,9 +2985,8 @@ int main(int argc, char *argv[])
         if (!options.keyStore.isEmpty() && !signPackage(options))
             return CannotSignPackage;

-        if (!options.apkPath.isEmpty() && !copyPackage(options)) {
-            // return CannotCopyApk;
-        }
+        if (!options.apkPath.isEmpty() && !copyPackage(options))
+            return CannotCopyApk;

         if (Q_UNLIKELY(options.timing))
             fprintf(stdout, "[TIMING] %d ms: Signed package\n", options.timer.elapsed());
